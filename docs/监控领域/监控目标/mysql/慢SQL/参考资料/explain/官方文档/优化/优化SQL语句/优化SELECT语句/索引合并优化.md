[MySQL 8.0参考手册](https://dev.mysql.com/doc/refman/8.0/en/) / [...](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html) / 索引合并优化

#### 8.2.1.3索引合并优化



该指数合并与多址接入方式检索行 [`range`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_range)扫描并合并他们的结果为一体。此访问方法仅合并来自单个表的索引扫描，而不合并多个表的扫描。合并可以为其基础扫描产生并集，相交或相交。

可能使用索引合并的示例查询：

```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;

SELECT * FROM tbl_name
  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
  AND t2.key1 = t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1 = 1
  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);
```

注意

索引合并优化算法具有以下已知限制：

- 如果您的查询包含`WHERE` 带有深度[`AND`](https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and)/[`OR`](https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or) 嵌套的复杂子句， 而MySQL没有选择最佳计划，请尝试使用以下身份转换来分发术语：

  ```sql
  (x AND y) OR z => (x OR z) AND (y OR z)
  (x OR y) AND z => (x AND z) OR (y AND z)
  ```

- 索引合并不适用于全文索引。

在[`EXPLAIN`](https://dev.mysql.com/doc/refman/8.0/en/explain.html)输出中，索引合并方法出现 [`index_merge`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index_merge)在 `type`列中。在这种情况下，该 `key`列包含使用的索引列表，并`key_len`包含这些索引的最长键部分的列表。

索引合并访问方法具有几种算法，这些算法显示在输出`Extra`字段中 [`EXPLAIN`](https://dev.mysql.com/doc/refman/8.0/en/explain.html)：

- `Using intersect(...)`
- `Using union(...)`
- `Using sort_union(...)`

以下各节将更详细地描述这些算法。优化程序根据各种可用选项的成本估算，在不同的可能索引合并算法和其他访问方法之间进行选择。

- [索引合并路口访问算法](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html#index-merge-intersection)
- [索引合并联合访问算法](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html#index-merge-union)
- [索引合并排序联合访问算法](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html#index-merge-sort-union)
- [影响索引合并优化](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html#index-merge-influencing)

##### 索引合并路口访问算法

当`WHERE`子句在与组合使用的不同键上转换为多个范围条件 [`AND`](https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and)，并且每个条件是以下条件之一时，此访问算法适用 ：

- *`N`*这种形式 的-part表达式，其中索引具有完全相同的 *`N`*部分（即，所有索引部分均被覆盖）：

  ```sql
  key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
  ```

- `InnoDB`表 主键上的任何范围条件 。

例子：

```sql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE key1_part1 = 1 AND key1_part2 = 2 AND key2 = 2;
```

索引合并交集算法对所有使用的索引执行同时扫描，并产生从合并索引扫描接收到的行序列的交集。

如果查询中使用的所有列都被使用的索引覆盖，则不会检索完整的表行（ 在这种情况下，[`EXPLAIN`](https://dev.mysql.com/doc/refman/8.0/en/explain.html)输出包含 `Using index`在`Extra`字段中）。这是此类查询的示例：

```sql
SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
```

如果使用的索引未覆盖查询中使用的所有列，则仅在满足所有使用的键的范围条件时才检索完整行。

如果合并的条件之一是`InnoDB`表主键上的条件，则该条件不用于行检索，而是用于过滤出使用其他条件检索的行。

##### 索引合并联合访问算法

该算法的标准类似于索引合并交集算法的标准。当表的`WHERE` 子句在与键组合在一起的不同键上转换为多个范围条件[`OR`](https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or)，并且每个条件是以下条件之一时，该算法适用：

- *`N`*这种形式 的-part表达式，其中索引具有完全相同的 *`N`*部分（即，所有索引部分均被覆盖）：

  ```sql
  key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
  ```

- `InnoDB`表 主键上的任何范围条件 。

- 索引合并交集算法适用的条件。

例子：

```sql
SELECT * FROM t1
  WHERE key1 = 1 OR key2 = 2 OR key3 = 3;

SELECT * FROM innodb_table
  WHERE (key1 = 1 AND key2 = 2)
     OR (key3 = 'foo' AND key4 = 'bar') AND key5 = 5;
```

##### 索引合并排序联合访问算法

当从`WHERE`子句转换为多个范围条件 时，此访问算法适用 [`OR`](https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or)，但索引合并并集算法不适用。

例子：

```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

排序联合算法和联合算法之间的区别在于，排序联合算法必须首先获取所有行的行ID，然后对它们进行排序，然后再返回任何行。

##### 影响索引合并优化

索引合并的使用是受价值 [`index_merge`](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_index-merge)， [`index_merge_intersection`](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_index-merge-intersection)， [`index_merge_union`](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_index-merge-union)，和 [`index_merge_sort_union`](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_index-merge-sort-union) 该旗 [`optimizer_switch`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)系统变量。请参见[第8.9.2节“可切换的优化”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。默认情况下，所有这些标志均为`on`。要仅启用某些算法，请将设置[`index_merge`](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_index-merge)为 `off`，并仅启用应允许的其他算法 。

除了在整个[`optimizer_switch`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)会话范围内使用 系统变量来控制优化器对索引合并算法的使用之外，MySQL还支持优化器提示，以根据每个语句影响优化器。请参见 [第8.9.3节“优化器提示”](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。